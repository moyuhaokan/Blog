
这个文章被翻译成了[西班牙语](https://www.campusmvp.es/recursos/post/fundamentos-de-javascript-por-que-deberias-saber-como-funciona-el-motor.aspx).

在这篇文章里面,我会详细说明身为一个前端开发者,应该知道的引擎,好让代码更好优化.



在下面的一行函数里面,他返回传递参数属性 lastName.给每个对象添加一个属性,我们最终性能下降超过 700%



我会详细解释,这是因为JavaScript 缺少静态类型导致的.曾经被视为优于其他语言（如C＃或Java）的优势，事实证明它更像是“讨价还价”。



通常,我们不需要去知道引擎内部怎么执行我们的代码.浏览器制造商投入很大的精力来让我们的代码执行的更快.



太棒了.



让其它的人去做这些繁重的工作,为啥担心引擎如何工作?



在下面的代码中,我们有五个对象存储firstname 和lastname.函数 getName返回lastname 这个值,我们测量这个函数运行一百万次

```js
(() => {   const han = {firstname: "Han", lastname: "Solo"};  const luke = {firstname: "Luke", lastname: "Skywalker"};  const leia = {firstname: "Leia", lastname: "Organa"};  const obi = {firstname: "Obi", lastname: "Wan"};  const yoda = {firstname: "", lastname: "Yoda"};  const people = [    han, luke, leia, obi,     yoda, luke, leia, obi   ];  const getName = (person) => person.lastname;
```



```js
  console.time("engine");  for(var i = 0; i < 1000 * 1000 * 1000; i++) {     getName(people[i & 7]);   }  console.timeEnd("engine"); })();
```



在 i7 4510U上面运行大概需要 1.2 秒,很棒,然后我们添加另一个属性到每一个对象上面,然后再执行一遍.





运行的时间是 8.5 秒.相对于第一个版本有一个因素影响了 7 秒的时间

这就像在高速行驶的时候刹着车.这中间发生了什么?

花一点时间去看下引擎吧





引擎是读取然后执行代码,每个主要的浏览器厂商都用自己的引擎.Firefox有Spidermonkey ,微软有 Chakra/ChakraCore .苹果Safari是JavaScriptCore,谷歌有 V8.同时也是 node.js 的引擎.



2008 年 V8 做出来了引擎历史上的关键一步.V8 取代了浏览器相对较慢的JavaScript 解释器.



这种大规模改进主要是 解释器和 编译器的结合.今天所有的引擎都使用这个技术.

解释器会立即执行代码.编译器产出机器码然后用户系统可以直接执行.

由于编译器的作用是产出机器码,它适合于优化, 尽管编译阶段需要额外的时间，但编译和优化都会导致更快的代码执行。



现代的引擎是结合了两者的优点.

 快速启动解释器。

快速执行编译器。



实现这两个目标源于解释器。 并行地，引擎将频繁执行的代码部分标记为“热路径”，并将它们与在执行期间收集的上下文信息一起传递给编译器。 此过程允许编译器调整和优化当前上下文的代码。

我们将编译器的行为称为“及时”或简称为JIT。
当引擎运行良好时，您可以想象某些情况下JavaScript甚至优于C ++。 难怪大多数引擎的工作都进入了“上下文优化”。





运行时静态类型：内联缓存
内联缓存（IC）是JavaScript引擎中的主要优化技术。 解释器必须先执行搜索才能访问对象的属性。 该属性可以是对象原型的一部分，具有getter方法，甚至可以通过代理访问。 在执行速度方面，搜索该属性非常昂贵。

引擎将每个对象分配给它在运行时生成的“类型”。 V8称这些“类型”，它们不是ECMAScript标准，隐藏类或对象形状的一部分。 要使两个对象共享相同的对象形状，两个对象必须具有完全相同的属性。 因此，对象{firstname：“Han”，lastname：“Solo”}将被分配给与{lastname：“Solo”，firstname：“Han”}不同的类。



在对象形状的帮助下，引擎知道每个属性的内存位置。 引擎将这些位置硬编码到访问属性的函数中。

内联缓存的作用是消除查找操作。 难怪这会带来巨大的性能提升。

回到前面的例子：第一次运行中的所有对象只有两个属性，firstname和lastname，顺序相同。 假设此对象形状的内部名称为p1。 当编译器应用IC时，它假定函数只传递给对象shapep1并立即返回lastname的值。



然而，在第二轮中，我们处理了5种不同的物体形状。 每个对象都有一个额外的属性，并且yoda完全缺少名字。 一旦我们处理多个对象形状会发生什么？

函数式编程具有众所周知的“鸭子打字”概念，其中良好的代码质量要求可以处理多种类型的函数。在我们的例子中，只要传递的对象具有属性姓氏，一切都很好。

内联缓存消除了对属性内存位置的昂贵查找。当在每个属性访问时，对象具有相同的对象形状时，它最有效。这称为单形IC。

如果我们有多达四种不同的对象形状，我们处于多态IC状态。与单态一样，优化的机器代码“已知”所有四个位置。但它必须检查传递的参数所属的四种可能的对象形状中的哪一种。这导致性能下降。

一旦我们超过四个阈值，它就会变得非常糟糕。我们现在处于一种所谓的变形IC中。在这种状态下，不再存在对存储器位置的本地缓存。相反，它必须从全局缓存中查找。这导致我们在上面看到的极端性能下降。

下面我们看到一个具有2种不同对象形状的多态Inline Cache。



我们的代码示例中的变形IC具有5种不同的对象形状：



好的，所以我们有5个对象形状并遇到了一个变形IC。 我们该如何解决这个问题？

我们必须确保引擎将所有5个对象标记为相同的对象形状。 这意味着我们创建的对象必须包含所有可能的属性。 我们可以使用对象文字，但我发现JavaScript类是更好的解决方案。

对于未定义的属性，我们只需传递null或将其保留。 构造函数确保使用以下值初始化这些字段：



当我们再次执行这个代码,我们看到执行时间又变成了1.2 秒



总结:

现代JavaScript引擎结合了解释器和编译器的优点：快速应用程序启动和快速代码执行。

内联缓存是一种强大的优化技术。 当只有一个对象形状传递给优化函数时，它最有效。

我的极端示例展示了内联缓存的不同类型的影响以及巨型缓存的性能损失。

使用JavaScript类是一种很好的做法。 像TypeScript这样的静态类型转换器使单形IC的可能性更大。
原文地址:

https://www.freecodecamp.org/news/javascript-essentials-why-you-should-know-how-the-engine-works-c2cc0d321553/

