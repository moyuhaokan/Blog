JavaScript 在开发者圈子当中名声不好,它是无类型,松散结构的,会引起浏览器的问题,Douglas Crockford是 JavaScript 的作者:JavaScript 包括了某些很常好的想法,也包含 了一些很糟糕的想法.JavaScript 在 1995只花了十天就创造出来了.直到三年之后 ECMA 才决定将其标准化,微软最初决定不支持新的标准,这差点就把 JavaScript 扼杀在摇篮期.



第一个 JavaScript 的引擎是 codenamed SpiderMonkey,是网景公司做的,只是简单的编译,读取和执行一些代码.在当时,JavaScript 通常包含一些写在页面顶部的函数和某些内联的事件.如果不急的话,解释代码还是令人满意的.



我们会跳过浮躁的十年,到 2004 年,谷歌退出了新的应用:谷歌地图,对于JavaScript 的开发者来说,这是一个变革,一个很慢很慢的变革.浏览器越陷越深,因为 JavaScript 引擎只是挖掘了一遍代码.



有无数的页面和和部分解释和说明了JavaScript 的引擎,关于实例,可以在文末"了解更多"查看.即使是很多专业的开发者也不知道的,现在我简单介绍一下 js 的引擎.特别是现在火热的 V8.

大多数 JavaScript 只需要几个步骤就可以处理代码,首先,词汇分析将代码分解成来标记识别其含义.然后解析器分析这些标记.并构建到中间语言的语法树中.最后编译器执行这些代码.





#####在 2008 年谷歌发布了增强版的引擎 -v8



v8引擎使用几个线程,这主线程,就像你预料的一样:获取代码,编译,执行.同时还有一个线程是编译的线程,以便于主线程可以继续执行,同时这个是优化代码,以及一个探查器的线程,它会把我们运行是花了大量时间的代码,以便于优化,还有一些线程是垃圾收集和死代码删除



v8有两个编译器,Full-Codegen和Crankshaft。

Full-Codegen将 JavaScript 直接编译成机器码,不需要中间语言,让它更快执行,名为Full-Codegen的JIT 编译器为热方法生成优化代码.这意味着在 V8 程序中,不同级别的代码可以同时共存.



速度来自于Crankshaft编译器.当 Full-Codgen 在运行时,运行时分析器会识别“热代码”这些代码已执行多次。此时，当前线程停止执行您的代码并将其传递给Crankshaft。所有优化的基础都是内联缓存，这是Smaltalk开创的技术。它包括立即用更好的代码修补代码。

解析后的JS首先被编译为一个名为Hydrogen的高级表示，其中大多数优化都已完成。这是类型特化发生的地方。 type-specialization删除了JavaScript所谓的装箱和拆箱操作。因此，例如，如果您的脚本经常在一组整数上运行一个函数，它会避免对解析字符串和浮点数的所有必要步骤进行排序，并保存解析整数所需的步骤，这样就不必运行它们再次。

因为JS是非类型的，所以不能保证专门生成的代码将继续工作。可以调用您的函数来处理字符串或双精度。现在必须对此代码进行去优化，从正在运行的线程中取出并替换为原始运行时代码。这是通过称为堆栈替换（OSR）的技术实现的。 OSR是在优化和未优化代码之间切换时保留当前堆栈帧语义的机制。使用OSR，当您的函数参数切换类型时，将拉出优化的代码并将您的线程转储回原始的Hydrogen生成的线程以进行重新编译。

Crankshafts的最终工作是将表示降低到一个名为Lithium的级别，这是特定于体系结构的。锂是最终转化为机器代码的表示。在这里，我们再次看到OSR。所有这些步骤都在您的浏览器或应用程序中运行，现在我们有一个完全编译和优化的版本，我们可以在执行过程中切换到优化版本。

只需运行两个编译器，性能就可以提高27％。而且还没有完成。每六周，V8团队就会发布一个新分支。 9月11日，该团队发布了6.2版，将在几周内与Chrome 62一起发布。下一个版本包括团队称之为“各种面向开发人员的好东西”和性能优化。你可以在这里阅读下一个版本。







原文地址:

https://www.mediacurrent.com/blog/brief-history-googles-v8-javascript-engine/

